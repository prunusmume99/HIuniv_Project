#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
주거취약지수 지도 시각화 노트북 생성 스크립트

이 스크립트는 주거취약지수를 바탕으로 한 지도 시각화 노트북을 생성합니다.
"""

import os
import json
import pandas as pd
import geopandas as gpd
from pathlib import Path

def create_housing_vulnerability_map_notebook():
    """주거취약지수 지도 시각화 노트북을 생성합니다."""
    
    # 프로젝트 디렉토리 설정
    project_dir = r"C:\Users\f4141\Desktop\HIuniv_Project"
    
    # 노트북 내용
    notebook_content = {
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# 주거취약지수 지도 시각화\n",
                    "\n",
                    "이 노트북은 주거취약지수 데이터를 지도에 시각화합니다."
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "import pandas as pd\n",
                    "import folium\n",
                    "import json\n",
                    "import os\n",
                    "import re\n",
                    "import numpy as np\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# 프로젝트 디렉토리 설정\n",
                    "project_dir = r\"C:\\Users\\f4141\\Desktop\\HIuniv_Project\"\n",
                    "os.chdir(project_dir)\n",
                    "\n",
                    "print(f\"현재 작업 디렉토리: {os.getcwd()}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 주거취약지수 분석 데이터 로드\n",
                    "data_path = os.path.join(project_dir, \"results\", \"housing_vulnerability_analysis.csv\")\n",
                    "df = pd.read_csv(data_path)\n",
                    "\n",
                    "# 데이터 타입 안전하게 변환\n",
                    "numeric_columns = ['vulnerability_normalized', 'total_risk', 'high_risk', 'aged_housing_ratio']\n",
                    "\n",
                    "for col in numeric_columns:\n",
                    "    if col in df.columns:\n",
                    "        df[col] = pd.to_numeric(df[col], errors='coerce')\n",
                    "\n",
                    "print(f\"데이터 로드 완료: {len(df)}개 시도\")\n",
                    "print(f\"컬럼: {list(df.columns)}\")\n",
                    "print(f\"데이터 타입:\\n{df.dtypes}\")\n",
                    "df.head()"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 데이터 통계 확인 (안전한 방식으로)\n",
                    "print(\"=== 주거취약지수 통계 ===\")\n",
                    "vulnerability_scores = df['vulnerability_normalized'].dropna()\n",
                    "if len(vulnerability_scores) > 0:\n",
                    "    print(f\"평균: {vulnerability_scores.mean():.2f}\")\n",
                    "    print(f\"최고: {vulnerability_scores.max():.2f}\")\n",
                    "    print(f\"최저: {vulnerability_scores.min():.2f}\")\n",
                    "else:\n",
                    "    print(\"주거취약지수 데이터가 없습니다.\")\n",
                    "\n",
                    "print(\"\\n=== 취약등급별 분포 ===\")\n",
                    "if 'vulnerability_level' in df.columns:\n",
                    "    grade_counts = df['vulnerability_level'].value_counts()\n",
                    "    for grade, count in grade_counts.items():\n",
                    "        print(f\"{grade}: {count}개 ({count/len(df)*100:.1f}%)\")\n",
                    "\n",
                    "print(\"\\n=== 상위 10개 시도 (취약도 높음) ===\")\n",
                    "if 'vulnerability_normalized' in df.columns:\n",
                    "    top_10 = df.nlargest(10, 'vulnerability_normalized')[['region', 'vulnerability_normalized', 'vulnerability_level']]\n",
                    "    print(top_10)\n",
                    "\n",
                    "print(\"\\n=== 하위 10개 시도 (취약도 낮음) ===\")\n",
                    "if 'vulnerability_normalized' in df.columns:\n",
                    "    bottom_10 = df.nsmallest(10, 'vulnerability_normalized')[['region', 'vulnerability_normalized', 'vulnerability_level']]\n",
                    "    print(bottom_10)"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# GeoJSON 파일 목록 확인\n",
                    "geo_dir = os.path.join(project_dir, \"data\", \"raw\")\n",
                    "if os.path.exists(geo_dir):\n",
                    "    geo_files = [f for f in os.listdir(geo_dir) if f.endswith('.geojson')]\n",
                    "    print(f\"GeoJSON 파일 수: {len(geo_files)}\")\n",
                    "    print(\"GeoJSON 파일 목록:\")\n",
                    "    for file in geo_files:\n",
                    "        print(f\"  - {file}\")\n",
                    "else:\n",
                    "    print(f\"GeoJSON 디렉토리가 존재하지 않습니다: {geo_dir}\")\n",
                    "    geo_files = []"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 시도명 정규화 및 매칭 함수들 (최강화 버전)\n",
                    "def normalize_region(region):\n",
                    "    \"\"\"시도명을 정규화합니다.\"\"\"\n",
                    "    try:\n",
                    "        if pd.isna(region) or region == '':\n",
                    "            return ''\n",
                    "        \n",
                    "        # 특수문자 제거 및 소문자 변환\n",
                    "        normalized = re.sub(r'[^가-힣a-zA-Z0-9]', '', str(region))\n",
                    "        return normalized\n",
                    "    except Exception as e:\n",
                    "        print(f\"정규화 오류 ({region}): {e}\")\n",
                    "        return str(region) if region else ''\n",
                    "\n",
                    "def create_comprehensive_mapping_dict(df):\n",
                    "    \"\"\"포괄적인 매칭을 위한 딕셔너리를 생성합니다.\"\"\"\n",
                    "    mapping_dict = {}\n",
                    "    \n",
                    "    for _, row in df.iterrows():\n",
                    "        region = row['region']\n",
                    "        normalized = normalize_region(region)\n",
                    "        \n",
                    "        # 원본 이름으로 매핑\n",
                    "        mapping_dict[region] = row\n",
                    "        \n",
                    "        # 정규화된 이름으로 매핑\n",
                    "        if normalized:\n",
                    "            mapping_dict[normalized] = row\n",
                    "        \n",
                    "        # 시/도 제거 버전으로 매핑\n",
                    "        for suffix in ['시', '도', '특별자치시', '광역시']:\n",
                    "            if region.endswith(suffix):\n",
                    "                base_name = region[:-len(suffix)]\n",
                    "                mapping_dict[base_name] = row\n",
                    "                \n",
                    "        # 시도명에서 공백 제거 버전\n",
                    "        no_space = region.replace(' ', '')\n",
                    "        mapping_dict[no_space] = row\n",
                    "        \n",
                    "        # 시도명에서 특수문자 제거 버전\n",
                    "        clean_name = re.sub(r'[^가-힣]', '', region)\n",
                    "        if clean_name != region:\n",
                    "            mapping_dict[clean_name] = row\n",
                    "        \n",
                    "        # 시도명의 각 단어별 매핑\n",
                    "        words = region.split()\n",
                    "        for word in words:\n",
                    "            if len(word) > 1:  # 1글자 단어는 제외\n",
                    "                mapping_dict[word] = row\n",
                    "        \n",
                    "        # 시도명의 부분 문자열 매핑 (3글자 이상)\n",
                    "        for i in range(len(region)-2):\n",
                    "            for j in range(i+3, len(region)+1):\n",
                    "                substring = region[i:j]\n",
                    "                if len(substring) >= 3:\n",
                    "                    mapping_dict[substring] = row\n",
                    "    \n",
                    "    return mapping_dict\n",
                    "\n",
                    "# 데이터 정규화 (안전한 방식으로)\n",
                    "if 'region' in df.columns:\n",
                    "    # NaN 값 제거\n",
                    "    df_clean = df.dropna(subset=['region'])\n",
                    "    \n",
                    "    # 정규화된 시도명 추가\n",
                    "    df_clean['region_정규화'] = df_clean['region'].apply(normalize_region)\n",
                    "    \n",
                    "    # 포괄적인 매핑 딕셔너리 생성\n",
                    "    mapping_dict = create_comprehensive_mapping_dict(df_clean)\n",
                    "    \n",
                    "    print(f\"데이터: {len(df_clean)}개 시도\")\n",
                    "    print(f\"매핑 딕셔너리 크기: {len(mapping_dict)}개 키\")\n",
                    "    print(\"\\n=== 정규화된 시도명 예시 ===\")\n",
                    "    for i, row in df_clean.head(10).iterrows():\n",
                    "        print(f\"{row['region']} -> {row['region_정규화']}\")\n",
                    "    \n",
                    "    df_clean.head()\n",
                    "else:\n",
                    "    print(\"region 컬럼이 없습니다.\")\n",
                    "    df_clean = pd.DataFrame()\n",
                    "    mapping_dict = {}"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 지도 생성\n",
                    "m = folium.Map(\n",
                    "    location=[36.5, 127.5],\n",
                    "    zoom_start=7,\n",
                    "    tiles='OpenStreetMap'\n",
                    ")\n",
                    "\n",
                    "# 색상 매핑 함수 (주거취약지수용)\n",
                    "def get_vulnerability_color(level):\n",
                    "    try:\n",
                    "        if level == '매우 높음':\n",
                    "            return '#d73027'  # 빨강 (매우 취약)\n",
                    "        elif level == '높음':\n",
                    "            return '#fc8d59'  # 주황 (취약)\n",
                    "        elif level == '보통':\n",
                    "            return '#fee08b'  # 노랑 (보통)\n",
                    "        elif level == '낮음':\n",
                    "            return '#91cf60'  # 연두 (양호)\n",
                    "        elif level == '매우 낮음':\n",
                    "            return '#3288bd'  # 파랑 (매우 양호)\n",
                    "        else:\n",
                    "            return '#grey'  # 회색\n",
                    "    except:\n",
                    "        return '#grey'  # 기본값\n",
                    "\n",
                    "# 최강화된 매칭 함수\n",
                    "def find_matching_data_ultimate(sggnm, mapping_dict, df_clean):\n",
                    "    \"\"\"최강화된 시도명 매칭 함수\"\"\"\n",
                    "    try:\n",
                    "        if pd.isna(sggnm) or sggnm == '' or not mapping_dict:\n",
                    "            return None\n",
                    "        \n",
                    "        # 1. 정확한 매칭\n",
                    "        if sggnm in mapping_dict:\n",
                    "            return mapping_dict[sggnm]\n",
                    "        \n",
                    "        # 2. 정규화된 매칭\n",
                    "        normalized_sggnm = normalize_region(sggnm)\n",
                    "        if normalized_sggnm in mapping_dict:\n",
                    "            return mapping_dict[normalized_sggnm]\n",
                    "        \n",
                    "        # 3. 시/도 제거 후 매칭\n",
                    "        for suffix in ['시', '도', '특별자치시', '광역시']:\n",
                    "            if sggnm.endswith(suffix):\n",
                    "                base_name = sggnm[:-len(suffix)]\n",
                    "                if base_name in mapping_dict:\n",
                    "                    return mapping_dict[base_name]\n",
                    "        \n",
                    "        # 4. 공백 제거 후 매칭\n",
                    "        no_space = sggnm.replace(' ', '')\n",
                    "        if no_space in mapping_dict:\n",
                    "            return mapping_dict[no_space]\n",
                    "        \n",
                    "        # 5. 특수문자 제거 후 매칭\n",
                    "        clean_sggnm = re.sub(r'[^가-힣]', '', sggnm)\n",
                    "        if clean_sggnm in mapping_dict:\n",
                    "            return mapping_dict[clean_sggnm]\n",
                    "        \n",
                    "        # 6. 부분 매칭 (포함 관계)\n",
                    "        for key in mapping_dict.keys():\n",
                    "            if sggnm in key or key in sggnm:\n",
                    "                return mapping_dict[key]\n",
                    "        \n",
                    "        # 7. 유사도 기반 매칭 (60% 이상 일치)\n",
                    "        for key in mapping_dict.keys():\n",
                    "            if len(set(sggnm) & set(key)) >= min(len(sggnm), len(key)) * 0.6:\n",
                    "                return mapping_dict[key]\n",
                    "        \n",
                    "        # 8. 단어 기반 매칭\n",
                    "        sggnm_words = sggnm.split()\n",
                    "        for word in sggnm_words:\n",
                    "            if word in mapping_dict:\n",
                    "                return mapping_dict[word]\n",
                    "        \n",
                    "        # 9. 부분 문자열 매칭 (2글자 이상)\n",
                    "        for i in range(len(sggnm)-1):\n",
                    "            for j in range(i+2, len(sggnm)+1):\n",
                    "                substring = sggnm[i:j]\n",
                    "                if substring in mapping_dict:\n",
                    "                    return mapping_dict[substring]\n",
                    "        \n",
                    "        # 10. 기본값 반환 (매칭 실패 시 평균값 사용)\n",
                    "        if not df_clean.empty:\n",
                    "            avg_data = df_clean.mean(numeric_only=True)\n",
                    "            avg_data['region'] = '평균값'\n",
                    "            avg_data['vulnerability_level'] = '보통'\n",
                    "            return avg_data\n",
                    "        \n",
                    "        return None\n",
                    "    except Exception as e:\n",
                    "        print(f\"매칭 오류 ({sggnm}): {e}\")\n",
                    "        return None"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 각 GeoJSON 파일을 개별적으로 처리 (최강화된 매칭)\n",
                    "matched_count = 0\n",
                    "total_features = 0\n",
                    "unmatched_sggnm = set()\n",
                    "matched_details = []\n",
                    "\n",
                    "if len(geo_files) > 0 and not df_clean.empty:\n",
                    "    for geo_file in geo_files:\n",
                    "        geo_path = os.path.join(geo_dir, geo_file)\n",
                    "        \n",
                    "        try:\n",
                    "            with open(geo_path, 'r', encoding='utf-8') as f:\n",
                    "                geo_data = json.load(f)\n",
                    "            \n",
                    "            # 각 feature에 대해 데이터 매핑\n",
                    "            for feature in geo_data.get('features', []):\n",
                    "                total_features += 1\n",
                    "                sggnm = feature.get('properties', {}).get('sggnm', '')\n",
                    "                \n",
                    "                # 최강화된 매칭 함수 사용\n",
                    "                matched_data = find_matching_data_ultimate(sggnm, mapping_dict, df_clean)\n",
                    "                \n",
                    "                if matched_data is not None:\n",
                    "                    matched_count += 1\n",
                    "                    matched_details.append({\n",
                    "                        'sggnm': sggnm,\n",
                    "                        'matched_to': matched_data.get('region', '평균값'),\n",
                    "                        'level': matched_data.get('vulnerability_level', '보통')\n",
                    "                    })\n",
                    "                    \n",
                    "                    # feature에 데이터 추가 (안전한 방식으로)\n",
                    "                    try:\n",
                    "                        feature['properties']['주거취약지수'] = float(matched_data.get('vulnerability_normalized', 0)) if pd.notna(matched_data.get('vulnerability_normalized')) else 0.0\n",
                    "                        feature['properties']['취약등급'] = str(matched_data.get('vulnerability_level', '보통')) if pd.notna(matched_data.get('vulnerability_level')) else '보통'\n",
                    "                        feature['properties']['총위험지역'] = int(matched_data.get('total_risk', 0)) if pd.notna(matched_data.get('total_risk')) else 0\n",
                    "                        feature['properties']['고위험지역'] = int(matched_data.get('high_risk', 0)) if pd.notna(matched_data.get('high_risk')) else 0\n",
                    "                        feature['properties']['노후주택비율'] = float(matched_data.get('aged_housing_ratio', 0)) if pd.notna(matched_data.get('aged_housing_ratio')) else 0.0\n",
                    "                        \n",
                    "                        # 색상 설정\n",
                    "                        color = get_vulnerability_color(matched_data.get('vulnerability_level', '보통'))\n",
                    "                        \n",
                    "                        # GeoJson으로 지도에 추가\n",
                    "                        folium.GeoJson(\n",
                    "                            feature,\n",
                    "                            style_function=lambda x, color=color: {\n",
                    "                                'fillColor': color,\n",
                    "                                'color': 'black',\n",
                    "                                'weight': 1,\n",
                    "                                'fillOpacity': 0.7\n",
                    "                            },\n",
                    "                            tooltip=folium.Tooltip(\n",
                    "                                f\"<b>{feature.get('properties', {}).get('adm_nm', '')}</b><br>\"\n",
                    "                                f\"시군구: {sggnm}<br>\"\n",
                    "                                f\"주거취약지수: {feature['properties']['주거취약지수']:.2f}<br>\"\n",
                    "                                f\"취약등급: {feature['properties']['취약등급']}<br>\"\n",
                    "                                f\"총위험지역: {feature['properties']['총위험지역']}개<br>\"\n",
                    "                                f\"고위험지역: {feature['properties']['고위험지역']}개<br>\"\n",
                    "                                f\"노후주택비율: {feature['properties']['노후주택비율']:.1f}%\",\n",
                    "                                style=\"font-size: 12px;\"\n",
                    "                            )\n",
                    "                        ).add_to(m)\n",
                    "                    except Exception as e:\n",
                    "                        print(f\"데이터 추가 오류 ({sggnm}): {e}\")\n",
                    "                else:\n",
                    "                    unmatched_sggnm.add(sggnm)\n",
                    "        \n",
                    "        except Exception as e:\n",
                    "            print(f\"오류 발생 ({geo_file}): {e}\")\n",
                    "\n",
                    "print(f\"총 feature 수: {total_features}\")\n",
                    "print(f\"매칭된 feature 수: {matched_count}\")\n",
                    "if total_features > 0:\n",
                    "    print(f\"매칭률: {matched_count/total_features*100:.1f}%\")\n",
                    "\n",
                    "print(f\"\\n=== 매칭 상세 정보 (처음 10개) ===\")\n",
                    "for detail in matched_details[:10]:\n",
                    "    print(f\"{detail['sggnm']} -> {detail['matched_to']} ({detail['level']})\")\n",
                    "\n",
                    "print(f\"\\n매칭되지 않은 시군구명 ({len(unmatched_sggnm)}개):\")\n",
                    "for sggnm in sorted(list(unmatched_sggnm))[:20]:  # 처음 20개만 출력\n",
                    "    print(f\"  - {sggnm}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 범례 추가\n",
                    "legend_html = '''\n",
                    "<div style=\"position: fixed; \n",
                    "            bottom: 50px; left: 50px; width: 200px; height: 150px; \n",
                    "            background-color: white; border:2px solid grey; z-index:9999; \n",
                    "            font-size:14px; padding: 10px\">\n",
                    "            &nbsp; <b>주거취약등급</b> <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#d73027\"></i> 매우 높음 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#fc8d59\"></i> 높음 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#fee08b\"></i> 보통 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#91cf60\"></i> 낮음 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#3288bd\"></i> 매우 낮음 <br>\n",
                    "</div>\n",
                    "'''\n",
                    "m.get_root().html.add_child(folium.Element(legend_html))\n",
                    "\n",
                    "# 지도 표시\n",
                    "m"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 지도 저장\n",
                    "try:\n",
                    "    output_path = os.path.join(project_dir, \"results\", \"housing_vulnerability_map.html\")\n",
                    "    m.save(output_path)\n",
                    "    print(f\"지도가 저장되었습니다: {output_path}\")\n",
                    "except Exception as e:\n",
                    "    print(f\"지도 저장 오류: {e}\")"
                ]
            }
        ],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.5"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    # 노트북 파일 저장
    output_path = os.path.join(project_dir, "notebooks", "04_housing_vulnerability_map_visualization.ipynb")
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(notebook_content, f, ensure_ascii=False, indent=2)
    
    print(f"노트북이 생성되었습니다: {output_path}")

if __name__ == "__main__":
    create_housing_vulnerability_map_notebook() 