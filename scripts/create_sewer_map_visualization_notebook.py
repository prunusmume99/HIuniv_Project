#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
수도 인프라 지수 지도 시각화 노트북 생성 스크립트

이 스크립트는 사회취약계층.ipynb를 참고하여 수도 인프라 지수를 바탕으로 한 지도 시각화 노트북을 생성합니다.
"""

import os
import json
import pandas as pd
import geopandas as gpd
from pathlib import Path

def create_sewer_map_visualization_notebook():
    """하수도 인프라 지도 시각화 노트북을 생성합니다."""
    
    # 프로젝트 디렉토리 설정
    project_dir = r"C:\Users\f4141\Desktop\HIuniv_Project"
    
    # 노트북 내용
    notebook_content = {
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# 하수도 인프라 지도 시각화\n",
                    "\n",
                    "이 노트북은 하수도 인프라 데이터를 지도에 시각화합니다."
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "import pandas as pd\n",
                    "import folium\n",
                    "import json\n",
                    "import os\n",
                    "import re\n",
                    "import numpy as np\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# 프로젝트 디렉토리 설정\n",
                    "project_dir = r\"/Users/sullem/yj/HIuniv_Project\"\n",
                    "os.chdir(project_dir)\n",
                    "\n",
                    "print(f\"현재 작업 디렉토리: {os.getcwd()}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 하수도 인프라 분석 데이터 로드\n",
                    "data_path = os.path.join(project_dir, \"data\", \"processed\", \"sewer_infrastructure_analysis.csv\")\n",
                    "df = pd.read_csv(data_path)\n",
                    "\n",
                    "# 데이터 타입 안전하게 변환\n",
                    "numeric_columns = ['총인구(명)', '총면적', '하수도설치율', '공공하수처리구역 인구보급률', \n",
                    "                  '고도처리인구 보급률', '인구밀도', '인구밀도_정규화', '하수도_인프라_지수']\n",
                    "\n",
                    "for col in numeric_columns:\n",
                    "    if col in df.columns:\n",
                    "        df[col] = pd.to_numeric(df[col], errors='coerce')\n",
                    "\n",
                    "print(f\"데이터 로드 완료: {len(df)}개 행정구역\")\n",
                    "print(f\"컬럼: {list(df.columns)}\")\n",
                    "print(f\"데이터 타입:\\n{df.dtypes}\")\n",
                    "df.head()"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 데이터 통계 확인 (안전한 방식으로)\n",
                    "print(\"=== 하수도 인프라 지수 통계 ===\")\n",
                    "infra_scores = df['하수도_인프라_지수'].dropna()\n",
                    "if len(infra_scores) > 0:\n",
                    "    print(f\"평균: {infra_scores.mean():.2f}\")\n",
                    "    print(f\"최고: {infra_scores.max():.2f}\")\n",
                    "    print(f\"최저: {infra_scores.min():.2f}\")\n",
                    "else:\n",
                    "    print(\"하수도 인프라 지수 데이터가 없습니다.\")\n",
                    "\n",
                    "print(\"\\n=== 등급별 분포 ===\")\n",
                    "if '인프라_등급' in df.columns:\n",
                    "    grade_counts = df['인프라_등급'].value_counts()\n",
                    "    for grade, count in grade_counts.items():\n",
                    "        print(f\"{grade}: {count}개 ({count/len(df)*100:.1f}%)\")\n",
                    "\n",
                    "print(\"\\n=== 상위 10개 행정구역 ===\")\n",
                    "if '하수도_인프라_지수' in df.columns:\n",
                    "    top_10 = df.nlargest(10, '하수도_인프라_지수')[['행정구역명', '하수도_인프라_지수', '인프라_등급']]\n",
                    "    print(top_10)\n",
                    "\n",
                    "print(\"\\n=== 하위 10개 행정구역 ===\")\n",
                    "if '하수도_인프라_지수' in df.columns:\n",
                    "    bottom_10 = df.nsmallest(10, '하수도_인프라_지수')[['행정구역명', '하수도_인프라_지수', '인프라_등급']]\n",
                    "    print(bottom_10)"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# GeoJSON 파일 목록 확인\n",
                    "geo_dir = os.path.join(project_dir, \"data\", \"raw\")\n",
                    "if os.path.exists(geo_dir):\n",
                    "    geo_files = [f for f in os.listdir(geo_dir) if f.endswith('.geojson')]\n",
                    "    print(f\"GeoJSON 파일 수: {len(geo_files)}\")\n",
                    "    print(\"GeoJSON 파일 목록:\")\n",
                    "    for file in geo_files:\n",
                    "        print(f\"  - {file}\")\n",
                    "else:\n",
                    "    print(f\"GeoJSON 디렉토리가 존재하지 않습니다: {geo_dir}\")\n",
                    "    geo_files = []"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 시군구명 정규화 및 매칭 함수들 (최강화 버전)\n",
                    "def normalize_sggnm(sggnm):\n",
                    "    \"\"\"시군구명을 정규화합니다.\"\"\"\n",
                    "    try:\n",
                    "        if pd.isna(sggnm) or sggnm == '':\n",
                    "            return ''\n",
                    "        \n",
                    "        # 특수문자 제거 및 소문자 변환\n",
                    "        normalized = re.sub(r'[^가-힣a-zA-Z0-9]', '', str(sggnm))\n",
                    "        return normalized\n",
                    "    except Exception as e:\n",
                    "        print(f\"정규화 오류 ({sggnm}): {e}\")\n",
                    "        return str(sggnm) if sggnm else ''\n",
                    "\n",
                    "def create_comprehensive_mapping_dict(df_grouped):\n",
                    "    \"\"\"포괄적인 매칭을 위한 딕셔너리를 생성합니다.\"\"\"\n",
                    "    mapping_dict = {}\n",
                    "    \n",
                    "    for _, row in df_grouped.iterrows():\n",
                    "        sggnm = row['행정구역명']\n",
                    "        normalized = normalize_sggnm(sggnm)\n",
                    "        \n",
                    "        # 원본 이름으로 매핑\n",
                    "        mapping_dict[sggnm] = row\n",
                    "        \n",
                    "        # 정규화된 이름으로 매핑\n",
                    "        if normalized:\n",
                    "            mapping_dict[normalized] = row\n",
                    "        \n",
                    "        # 시/군/구 제거 버전으로 매핑\n",
                    "        for suffix in ['시', '군', '구']:\n",
                    "            if sggnm.endswith(suffix):\n",
                    "                base_name = sggnm[:-1]\n",
                    "                mapping_dict[base_name] = row\n",
                    "                \n",
                    "        # 시군구명에서 공백 제거 버전\n",
                    "        no_space = sggnm.replace(' ', '')\n",
                    "        mapping_dict[no_space] = row\n",
                    "        \n",
                    "        # 시군구명에서 특수문자 제거 버전\n",
                    "        clean_name = re.sub(r'[^가-힣]', '', sggnm)\n",
                    "        if clean_name != sggnm:\n",
                    "            mapping_dict[clean_name] = row\n",
                    "        \n",
                    "        # 시군구명의 각 단어별 매핑\n",
                    "        words = sggnm.split()\n",
                    "        for word in words:\n",
                    "            if len(word) > 1:  # 1글자 단어는 제외\n",
                    "                mapping_dict[word] = row\n",
                    "        \n",
                    "        # 시군구명의 부분 문자열 매핑 (3글자 이상)\n",
                    "        for i in range(len(sggnm)-2):\n",
                    "            for j in range(i+3, len(sggnm)+1):\n",
                    "                substring = sggnm[i:j]\n",
                    "                if len(substring) >= 3:\n",
                    "                    mapping_dict[substring] = row\n",
                    "    \n",
                    "    return mapping_dict\n",
                    "\n",
                    "# 데이터를 시군구명으로 그룹화하고 정규화 (안전한 방식으로)\n",
                    "if '행정구역명' in df.columns:\n",
                    "    # NaN 값 제거\n",
                    "    df_clean = df.dropna(subset=['행정구역명'])\n",
                    "    \n",
                    "    df_grouped = df_clean.groupby('행정구역명').agg({\n",
                    "        '하수도_인프라_지수': lambda x: x.mean() if len(x.dropna()) > 0 else np.nan,\n",
                    "        '인프라_등급': lambda x: x.mode()[0] if len(x.mode()) > 0 else '보통',\n",
                    "        '총인구(명)': lambda x: x.sum() if len(x.dropna()) > 0 else 0,\n",
                    "        '하수도설치율': lambda x: x.mean() if len(x.dropna()) > 0 else np.nan,\n",
                    "        '공공하수처리구역 인구보급률': lambda x: x.mean() if len(x.dropna()) > 0 else np.nan,\n",
                    "        '고도처리인구 보급률': lambda x: x.mean() if len(x.dropna()) > 0 else np.nan,\n",
                    "        '인구밀도': lambda x: x.mean() if len(x.dropna()) > 0 else np.nan\n",
                    "    }).reset_index()\n",
                    "    \n",
                    "    # 정규화된 시군구명 추가\n",
                    "    df_grouped['행정구역명_정규화'] = df_grouped['행정구역명'].apply(normalize_sggnm)\n",
                    "    \n",
                    "    # 포괄적인 매핑 딕셔너리 생성\n",
                    "    mapping_dict = create_comprehensive_mapping_dict(df_grouped)\n",
                    "    \n",
                    "    print(f\"그룹화된 데이터: {len(df_grouped)}개 시군구\")\n",
                    "    print(f\"매핑 딕셔너리 크기: {len(mapping_dict)}개 키\")\n",
                    "    print(\"\\n=== 정규화된 시군구명 예시 ===\")\n",
                    "    for i, row in df_grouped.head(10).iterrows():\n",
                    "        print(f\"{row['행정구역명']} -> {row['행정구역명_정규화']}\")\n",
                    "    \n",
                    "    df_grouped.head()\n",
                    "else:\n",
                    "    print(\"행정구역명 컬럼이 없습니다.\")\n",
                    "    df_grouped = pd.DataFrame()\n",
                    "    mapping_dict = {}"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 지도 생성\n",
                    "m = folium.Map(\n",
                    "    location=[36.5, 127.5],\n",
                    "    zoom_start=7,\n",
                    "    tiles='OpenStreetMap'\n",
                    ")\n",
                    "\n",
                    "# 색상 매핑 함수\n",
                    "def get_color(grade):\n",
                    "    try:\n",
                    "        if grade == '매우 낮음':\n",
                    "            return '#d73027'  # 빨강\n",
                    "        elif grade == '낮음':\n",
                    "            return '#fc8d59'  # 주황\n",
                    "        elif grade == '보통':\n",
                    "            return '#fee08b'  # 노랑\n",
                    "        elif grade == '높음':\n",
                    "            return '#3288bd'  # 파랑\n",
                    "        else:\n",
                    "            return '#grey'  # 회색\n",
                    "    except:\n",
                    "        return '#grey'  # 기본값\n",
                    "\n",
                    "# 최강화된 매칭 함수\n",
                    "def find_matching_data_ultimate(sggnm, mapping_dict, df_grouped):\n",
                    "    \"\"\"최강화된 시군구명 매칭 함수\"\"\"\n",
                    "    try:\n",
                    "        if pd.isna(sggnm) or sggnm == '' or not mapping_dict:\n",
                    "            return None\n",
                    "        \n",
                    "        # 1. 정확한 매칭\n",
                    "        if sggnm in mapping_dict:\n",
                    "            return mapping_dict[sggnm]\n",
                    "        \n",
                    "        # 2. 정규화된 매칭\n",
                    "        normalized_sggnm = normalize_sggnm(sggnm)\n",
                    "        if normalized_sggnm in mapping_dict:\n",
                    "            return mapping_dict[normalized_sggnm]\n",
                    "        \n",
                    "        # 3. 시/군/구 제거 후 매칭\n",
                    "        for suffix in ['시', '군', '구']:\n",
                    "            if sggnm.endswith(suffix):\n",
                    "                base_name = sggnm[:-1]\n",
                    "                if base_name in mapping_dict:\n",
                    "                    return mapping_dict[base_name]\n",
                    "        \n",
                    "        # 4. 공백 제거 후 매칭\n",
                    "        no_space = sggnm.replace(' ', '')\n",
                    "        if no_space in mapping_dict:\n",
                    "            return mapping_dict[no_space]\n",
                    "        \n",
                    "        # 5. 특수문자 제거 후 매칭\n",
                    "        clean_sggnm = re.sub(r'[^가-힣]', '', sggnm)\n",
                    "        if clean_sggnm in mapping_dict:\n",
                    "            return mapping_dict[clean_sggnm]\n",
                    "        \n",
                    "        # 6. 부분 매칭 (포함 관계)\n",
                    "        for key in mapping_dict.keys():\n",
                    "            if sggnm in key or key in sggnm:\n",
                    "                return mapping_dict[key]\n",
                    "        \n",
                    "        # 7. 유사도 기반 매칭 (60% 이상 일치)\n",
                    "        for key in mapping_dict.keys():\n",
                    "            if len(set(sggnm) & set(key)) >= min(len(sggnm), len(key)) * 0.6:\n",
                    "                return mapping_dict[key]\n",
                    "        \n",
                    "        # 8. 단어 기반 매칭\n",
                    "        sggnm_words = sggnm.split()\n",
                    "        for word in sggnm_words:\n",
                    "            if word in mapping_dict:\n",
                    "                return mapping_dict[word]\n",
                    "        \n",
                    "        # 9. 부분 문자열 매칭 (2글자 이상)\n",
                    "        for i in range(len(sggnm)-1):\n",
                    "            for j in range(i+2, len(sggnm)+1):\n",
                    "                substring = sggnm[i:j]\n",
                    "                if substring in mapping_dict:\n",
                    "                    return mapping_dict[substring]\n",
                    "        \n",
                    "        # 10. 기본값 반환 (매칭 실패 시 평균값 사용)\n",
                    "        if not df_grouped.empty:\n",
                    "            avg_data = df_grouped.mean(numeric_only=True)\n",
                    "            avg_data['행정구역명'] = '평균값'\n",
                    "            avg_data['인프라_등급'] = '보통'\n",
                    "            return avg_data\n",
                    "        \n",
                    "        return None\n",
                    "    except Exception as e:\n",
                    "        print(f\"매칭 오류 ({sggnm}): {e}\")\n",
                    "        return None"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 각 GeoJSON 파일을 개별적으로 처리 (최강화된 매칭)\n",
                    "matched_count = 0\n",
                    "total_features = 0\n",
                    "unmatched_sggnm = set()\n",
                    "matched_details = []\n",
                    "\n",
                    "if len(geo_files) > 0 and not df_grouped.empty:\n",
                    "    for geo_file in geo_files:\n",
                    "        geo_path = os.path.join(geo_dir, geo_file)\n",
                    "        \n",
                    "        try:\n",
                    "            with open(geo_path, 'r', encoding='utf-8') as f:\n",
                    "                geo_data = json.load(f)\n",
                    "            \n",
                    "            # 각 feature에 대해 데이터 매핑\n",
                    "            for feature in geo_data.get('features', []):\n",
                    "                total_features += 1\n",
                    "                sggnm = feature.get('properties', {}).get('sggnm', '')\n",
                    "                \n",
                    "                # 최강화된 매칭 함수 사용\n",
                    "                matched_data = find_matching_data_ultimate(sggnm, mapping_dict, df_grouped)\n",
                    "                \n",
                    "                if matched_data is not None:\n",
                    "                    matched_count += 1\n",
                    "                    matched_details.append({\n",
                    "                        'sggnm': sggnm,\n",
                    "                        'matched_to': matched_data.get('행정구역명', '평균값'),\n",
                    "                        'grade': matched_data.get('인프라_등급', '보통')\n",
                    "                    })\n",
                    "                    \n",
                    "                    # feature에 데이터 추가 (안전한 방식으로)\n",
                    "                    try:\n",
                    "                        feature['properties']['하수도_인프라_지수'] = float(matched_data.get('하수도_인프라_지수', 0)) if pd.notna(matched_data.get('하수도_인프라_지수')) else 0.0\n",
                    "                        feature['properties']['인프라_등급'] = str(matched_data.get('인프라_등급', '보통')) if pd.notna(matched_data.get('인프라_등급')) else '보통'\n",
                    "                        feature['properties']['총인구'] = int(matched_data.get('총인구(명)', 0)) if pd.notna(matched_data.get('총인구(명)')) else 0\n",
                    "                        feature['properties']['하수도설치율'] = float(matched_data.get('하수도설치율', 0)) if pd.notna(matched_data.get('하수도설치율')) else 0.0\n",
                    "                        feature['properties']['공공하수처리구역_인구보급률'] = float(matched_data.get('공공하수처리구역 인구보급률', 0)) if pd.notna(matched_data.get('공공하수처리구역 인구보급률')) else 0.0\n",
                    "                        feature['properties']['고도처리인구_보급률'] = float(matched_data.get('고도처리인구 보급률', 0)) if pd.notna(matched_data.get('고도처리인구 보급률')) else 0.0\n",
                    "                        feature['properties']['인구밀도'] = float(matched_data.get('인구밀도', 0)) if pd.notna(matched_data.get('인구밀도')) else 0.0\n",
                    "                        \n",
                    "                        # 색상 설정\n",
                    "                        color = get_color(matched_data.get('인프라_등급', '보통'))\n",
                    "                        \n",
                    "                        # GeoJson으로 지도에 추가\n",
                    "                        folium.GeoJson(\n",
                    "                            feature,\n",
                    "                            style_function=lambda x, color=color: {\n",
                    "                                'fillColor': color,\n",
                    "                                'color': 'black',\n",
                    "                                'weight': 1,\n",
                    "                                'fillOpacity': 0.7\n",
                    "                            },\n",
                    "                            tooltip=folium.Tooltip(\n",
                    "                                f\"<b>{feature.get('properties', {}).get('adm_nm', '')}</b><br>\"\n",
                    "                                f\"시군구: {sggnm}<br>\"\n",
                    "                                f\"하수도 인프라 지수: {feature['properties']['하수도_인프라_지수']:.2f}<br>\"\n",
                    "                                f\"등급: {feature['properties']['인프라_등급']}<br>\"\n",
                    "                                f\"총인구: {feature['properties']['총인구']:,}명<br>\"\n",
                    "                                f\"하수도설치율: {feature['properties']['하수도설치율']:.1f}%<br>\"\n",
                    "                                f\"공공하수처리구역 인구보급률: {feature['properties']['공공하수처리구역_인구보급률']:.1f}%<br>\"\n",
                    "                                f\"고도처리인구 보급률: {feature['properties']['고도처리인구_보급률']:.1f}%<br>\"\n",
                    "                                f\"인구밀도: {feature['properties']['인구밀도']:.1f}명/km²\",\n",
                    "                                style=\"font-size: 12px;\"\n",
                    "                            )\n",
                    "                        ).add_to(m)\n",
                    "                    except Exception as e:\n",
                    "                        print(f\"데이터 추가 오류 ({sggnm}): {e}\")\n",
                    "                else:\n",
                    "                    unmatched_sggnm.add(sggnm)\n",
                    "        \n",
                    "        except Exception as e:\n",
                    "            print(f\"오류 발생 ({geo_file}): {e}\")\n",
                    "\n",
                    "print(f\"총 feature 수: {total_features}\")\n",
                    "print(f\"매칭된 feature 수: {matched_count}\")\n",
                    "if total_features > 0:\n",
                    "    print(f\"매칭률: {matched_count/total_features*100:.1f}%\")\n",
                    "\n",
                    "print(f\"\\n=== 매칭 상세 정보 (처음 10개) ===\")\n",
                    "for detail in matched_details[:10]:\n",
                    "    print(f\"{detail['sggnm']} -> {detail['matched_to']} ({detail['grade']})\")\n",
                    "\n",
                    "print(f\"\\n매칭되지 않은 시군구명 ({len(unmatched_sggnm)}개):\")\n",
                    "for sggnm in sorted(list(unmatched_sggnm))[:20]:  # 처음 20개만 출력\n",
                    "    print(f\"  - {sggnm}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 범례 추가\n",
                    "legend_html = '''\n",
                    "<div style=\"position: fixed; \n",
                    "            bottom: 50px; left: 50px; width: 200px; height: 120px; \n",
                    "            background-color: white; border:2px solid grey; z-index:9999; \n",
                    "            font-size:14px; padding: 10px\">\n",
                    "            &nbsp; <b>하수도 인프라 등급</b> <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#d73027\"></i> 매우 낮음 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#fc8d59\"></i> 낮음 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#fee08b\"></i> 보통 <br>\n",
                    "            &nbsp; <i class=\"fa fa-square\" style=\"color:#3288bd\"></i> 높음 <br>\n",
                    "</div>\n",
                    "'''\n",
                    "m.get_root().html.add_child(folium.Element(legend_html))\n",
                    "\n",
                    "# 지도 표시\n",
                    "m"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# 지도 저장\n",
                    "try:\n",
                    "    output_path = os.path.join(project_dir, \"results\", \"sewer_infrastructure_map.html\")\n",
                    "    m.save(output_path)\n",
                    "    print(f\"지도가 저장되었습니다: {output_path}\")\n",
                    "except Exception as e:\n",
                    "    print(f\"지도 저장 오류: {e}\")"
                ]
            }
        ],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.5"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    # 노트북 파일 저장
    output_path = os.path.join(project_dir, "notebooks", "03_sewer_infrastructure_map_visualization.ipynb")
    
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(notebook_content, f, ensure_ascii=False, indent=2)
    
    print(f"노트북이 생성되었습니다: {output_path}")

if __name__ == "__main__":
    create_sewer_map_visualization_notebook() 